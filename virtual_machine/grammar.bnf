%lex

%%

\/\/.*             %empty
\/\*[\s\S]*?\*\/   %empty

\s+                %empty

"+"                PLUS
"-"                MINUS
"*"                MULTIPLY
"/"                DIVIDE

"=="               EQUALS
"!="               NOT_EQUALS
"<="               LESS_EQUAL
">="               GREATER_EQUAL
"<"                LESS
">"                GREATER

"if"               IF
"while"            WHILE
"for"              FOR
"var"              VAR

"func"             FUNC
"return"            RETURN

"="                ASSIGN
";"                SEMICOLON

"("                L_PAREN
")"                R_PAREN

"{"                L_BRACE
"}"                R_BRACE

"else"             ELSE

"&&"               LOGICAL_AND
"||"               LOGICAL_OR
"!"                LOGICAL_NOT

\"[^\"]*\"         STRING

\d+                NUMBER

[\w]+              SYMBOL

/lex


%{

#include <string>
#include <vector>
#include <memory>

enum class ExpType {
    NUMBER,
    STRING,
    SYMBOL,
    BINARY_EXP,
    UNARY_EXP,
    IF_EXP,
    WHILE_EXP,
    FOR_EXP,
    VAR_DECLARATION,
    BLOCK,
    ASSIGNMENT,
    FUNCTION_DECLARATION,
    FUNCTION_CALL,
    PARAM_LIST,
    ARG_LIST,
    RETURN_EXP
};

struct Exp {
    ExpType type;

    int number;
    std::string string;

    std::string op;
    std::shared_ptr<Exp> left;
    std::shared_ptr<Exp> right;

    std::shared_ptr<Exp> condition;
    std::shared_ptr<Exp> thenBranch;
    std::shared_ptr<Exp> elseBranch;

    std::string varName;
    std::shared_ptr<Exp> varValue;

    std::vector<std::shared_ptr<Exp>> statements;

    std::string unaryOp;
    std::shared_ptr<Exp> operand;

    std::shared_ptr<Exp> whileBody;

    std::shared_ptr<Exp> forInit;
    std::shared_ptr<Exp> forCondition;
    std::shared_ptr<Exp> forUpdate;
    std::shared_ptr<Exp> forBody;

    std::string funcName;
    std::vector<std::string> funcParams; // For PARAM_LIST or FUNCTION_DECLARATION
    std::shared_ptr<Exp> funcBody;

    std::vector<std::shared_ptr<Exp>> callArguments; // For ARG_LIST or FUNCTION_CALL

    // Constructors

    // For PARAM_LIST
    Exp(ExpType type, const std::vector<std::string> &params)
        : type(type), funcParams(params) {}

    // For ARG_LIST
    Exp(ExpType type, const std::vector<std::shared_ptr<Exp>> &args)
        : type(type), callArguments(args) {}

    // FUNCTION_DECLARATION constructor
    Exp(ExpType type, const std::string &name, const std::vector<std::string> &params, std::shared_ptr<Exp> body)
        : type(type), funcName(name), funcParams(params), funcBody(body) {}

    // FUNCTION_CALL constructor
    Exp(ExpType type, const std::string &name, const std::vector<std::shared_ptr<Exp>> &args)
        : type(type), funcName(name), callArguments(args) {}

    // For NUMBER
    Exp(int number) : type(ExpType::NUMBER), number(number) {}

    // For STRING and SYMBOL
    Exp(const std::string& strVal) {
        if (strVal[0] == '"') {
            type = ExpType::STRING;
            string = strVal.substr(1, strVal.size() - 2);
        } else {
            type = ExpType::SYMBOL;
            string = strVal;
        }
    }

  // For return statements
    Exp(ExpType type, std::shared_ptr<Exp> value)
        : type(type), varValue(value) {}

    // For UNARY_EXP
    Exp(const std::string& unaryOp, std::shared_ptr<Exp> operand)
        : type(ExpType::UNARY_EXP), unaryOp(unaryOp), operand(operand) {}

    // For VAR_DECLARATION
    Exp(ExpType expType, const std::string& varName, std::shared_ptr<Exp> varValue)
        : type(expType), varName(varName), varValue(varValue) {}

    // For BINARY_EXP
    Exp(const std::string& op, std::shared_ptr<Exp> left, std::shared_ptr<Exp> right)
        : type(ExpType::BINARY_EXP), op(op), left(left), right(right) {}

    // For IF_EXP
    Exp(ExpType expType, std::shared_ptr<Exp> condition, std::shared_ptr<Exp> thenBranch, std::shared_ptr<Exp> elseBranch)
        : type(expType), condition(condition), thenBranch(thenBranch), elseBranch(elseBranch) {}

    // For BLOCK
    Exp(const std::vector<std::shared_ptr<Exp>>& statements)
        : type(ExpType::BLOCK), statements(statements) {}

    // For WHILE_EXP
    Exp(ExpType expType, std::shared_ptr<Exp> condition, std::shared_ptr<Exp> whileBody)
        : type(expType), condition(condition), whileBody(whileBody) {}

    // For FOR_EXP
    Exp(ExpType expType,
        std::shared_ptr<Exp> forInit,
        std::shared_ptr<Exp> forCondition,
        std::shared_ptr<Exp> forUpdate,
        std::shared_ptr<Exp> forBody)
        : type(expType),
          forInit(forInit),
          forCondition(forCondition),
          forUpdate(forUpdate),
          forBody(forBody) {}
};

using Value = std::shared_ptr<Exp>;

%}

%token IF
%token ELSE
%token WHILE
%token FOR
%token VAR
%token FUNC

%token ASSIGN
%token SEMICOLON

%token L_BRACE
%token R_BRACE
%token L_PAREN
%token R_PAREN

%token NUMBER

%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE

%token EQUALS
%token NOT_EQUALS
%token LESS
%token GREATER
%token LESS_EQUAL
%token GREATER_EQUAL

%token LOGICAL_AND
%token LOGICAL_OR
%token LOGICAL_NOT

%token RETURN

%token STRING
%token SYMBOL

%%

Program
    ::= StatementList
        { $$ = $1; }
    ;

StatementList
    ::= Statement
        { $$ = std::make_shared<Exp>(std::vector<std::shared_ptr<Exp>>{ $1 }); }
    | StatementList Statement
        { $1->statements.push_back($2); $$ = $1; }
    ;

Statement
    ::= IfStatement
    | WhileStatement
    | ForStatement
    | FunctionDeclaration
    | ReturnStatement       /* Add this line to include return statements */
    | VarDeclaration
    | Expression SEMICOLON
    ;

ReturnStatement
    ::= RETURN Expression SEMICOLON
        { $$ = std::make_shared<Exp>(ExpType::RETURN_EXP, $2); }
    ;

VarDeclaration
    ::= VAR SYMBOL ASSIGN Expression SEMICOLON
        { $$ = std::make_shared<Exp>(ExpType::VAR_DECLARATION, $2, $4); }
    ;

FunctionDeclaration
    ::= FUNC SYMBOL L_PAREN ParameterList R_PAREN Block
        {
            $$ = std::make_shared<Exp>(
                ExpType::FUNCTION_DECLARATION,
                $2,
                *$4,
                $6
            );
            delete $4;
        }
    ;

Block
    ::= L_BRACE StatementList R_BRACE
        { $$ = std::make_shared<Exp>($2->statements); }
    ;

IfStatement
    ::= IF L_PAREN Expression R_PAREN Statement ELSE Statement
        { $$ = std::make_shared<Exp>(ExpType::IF_EXP, $3, $5, $7); }
    | IF L_PAREN Expression R_PAREN Statement
        { $$ = std::make_shared<Exp>(ExpType::IF_EXP, $3, $5, nullptr); }
    ;

WhileStatement
    ::= WHILE L_PAREN Expression R_PAREN Statement
        { $$ = std::make_shared<Exp>(ExpType::WHILE_EXP, $3, $5); }
    ;

ForStatement
    ::= FOR L_PAREN ForInit SEMICOLON ForCondition SEMICOLON ForUpdate R_PAREN Statement
        { $$ = std::make_shared<Exp>(ExpType::FOR_EXP, $3, $5, $7, $9); }
    ;

ForInit
    ::= VarDeclaration
        { $$ = $1; }
    | Expression
        { $$ = $1; }
    | /* empty */
        { $$ = nullptr; }
    ;

ForCondition
    ::= Expression
        { $$ = $1; }
    | /* empty */
        { $$ = nullptr; }
    ;

ForUpdate
    ::= Expression
        { $$ = $1; }
    | /* empty */
        { $$ = nullptr; }
    ;

Expression
    ::= Assignment
    | LogicalOrExpression
    ;

Assignment
    ::= SYMBOL ASSIGN Expression
        { $$ = std::make_shared<Exp>(ExpType::ASSIGNMENT, $1, $3); }
    ;

LogicalOrExpression
    ::= LogicalOrExpression LOGICAL_OR LogicalAndExpression
        { $$ = std::make_shared<Exp>("||", $1, $3); }
    | LogicalAndExpression
        { $$ = $1; }
    ;

LogicalAndExpression
    ::= LogicalAndExpression LOGICAL_AND EqualityExpression
        { $$ = std::make_shared<Exp>("&&", $1, $3); }
    | EqualityExpression
        { $$ = $1; }
    ;

EqualityExpression
    ::= EqualityExpression EQUALS RelationalExpression
        { $$ = std::make_shared<Exp>("==", $1, $3); }
    | EqualityExpression NOT_EQUALS RelationalExpression
        { $$ = std::make_shared<Exp>("!=", $1, $3); }
    | RelationalExpression
        { $$ = $1; }
    ;

RelationalExpression
    ::= RelationalExpression LESS AdditiveExpression
        { $$ = std::make_shared<Exp>("<", $1, $3); }
    | RelationalExpression GREATER AdditiveExpression
        { $$ = std::make_shared<Exp>(">", $1, $3); }
    | RelationalExpression LESS_EQUAL AdditiveExpression
        { $$ = std::make_shared<Exp>("<=", $1, $3); }
    | RelationalExpression GREATER_EQUAL AdditiveExpression
        { $$ = std::make_shared<Exp>(">=", $1, $3); }
    | AdditiveExpression
        { $$ = $1; }
    ;

AdditiveExpression
    ::= AdditiveExpression PLUS MultiplicativeExpression
        { $$ = std::make_shared<Exp>("+", $1, $3); }
    | AdditiveExpression MINUS MultiplicativeExpression
        { $$ = std::make_shared<Exp>("-", $1, $3); }
    | MultiplicativeExpression
        { $$ = $1; }
    ;

MultiplicativeExpression
    ::= MultiplicativeExpression MULTIPLY UnaryExpression
        { $$ = std::make_shared<Exp>("*", $1, $3); }
    | MultiplicativeExpression DIVIDE UnaryExpression
        { $$ = std::make_shared<Exp>("/", $1, $3); }
    | UnaryExpression
        { $$ = $1; }
    ;

UnaryExpression
    ::= LOGICAL_NOT UnaryExpression
        { $$ = std::make_shared<Exp>("!", $2); }
    | PrimaryExpression
        { $$ = $1; }
    ;

PrimaryExpression
    ::= L_PAREN Expression R_PAREN
        { $$ = $2; }
    | NUMBER
        { $$ = std::make_shared<Exp>(std::stoi($1)); }
    | STRING
        { $$ = std::make_shared<Exp>($1); }
    | SYMBOL L_PAREN ArgumentList R_PAREN
        {
            /* Function call */
            $$ = std::make_shared<Exp>(
                ExpType::FUNCTION_CALL,
                $1,
                *$3
            );
            delete $3;
        }
    | SYMBOL
        { $$ = std::make_shared<Exp>($1); }
    ;

ArgumentList
    ::= /* empty */
        { $$ = new std::vector<std::shared_ptr<Exp>>(); }
    | ExpressionList
        { $$ = $1; }
    ;

ExpressionList
    ::= Expression
        {
            $$ = new std::vector<std::shared_ptr<Exp>>();
            $$->push_back($1);
        }
    | ExpressionList "," Expression
        {
            $1->push_back($3);
            $$ = $1;
        }
    ;

ParameterList
    ::= /* empty */
        { $$ = new std::vector<std::string>(); }
    | SymbolList
        { $$ = $1; }
    ;

SymbolList
    ::= SYMBOL
        {
            $$ = new std::vector<std::string>();
            $$->push_back($1);
        }
    | SymbolList "," SYMBOL
        {
            $1->push_back($3);
            $$ = $1;
        }
    ;

