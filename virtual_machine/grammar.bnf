%lex

%%

\/\/.*             %empty
\/\*[\s\S]*?\*\/   %empty

\s+                %empty



"+"                PLUS
"-"                MINUS
"*"                MULTIPLY
"/"                DIVIDE

"=="               EQUALS
"!="               NOT_EQUALS
"<="               LESS_EQUAL
">="               GREATER_EQUAL
"<"                LESS
">"                GREATER

"if"               IF
"var"              VAR

"="                ASSIGN
";"                SEMICOLON


"("                L_PAREN
")"                R_PAREN

"{"                 L_BRACE
"}"                 R_BRACE

"else"              ELSE

"&&"                LOGICAL_AND
"||"              LOGICAL_OR
"!"                 LOGICAL_NOT


\"[^\"]*\"         STRING

\d+                NUMBER

[\w]+              SYMBOL

/lex
%{

#include <string>
#include <vector>
#include <memory>

/**
 * Expression type.
 */
enum class ExpType {
  NUMBER,
  STRING,
  SYMBOL,
  BINARY_EXP,
  UNARY_EXP,       // for unary operators like '!'
  IF_EXP,
  VAR_DECLARATION,
  BLOCK, // For statement lists or programs
  ASSIGNMENT
};

/**
 * Expression.
 */
struct Exp {
  ExpType type;

  // For NUMBER
  int number;

  // For STRING and SYMBOL
  std::string string;

  // For BINARY_EXP
  std::string op;
  std::shared_ptr<Exp> left;
  std::shared_ptr<Exp> right;

  // For IF_EXP
  std::shared_ptr<Exp> condition;
  std::shared_ptr<Exp> thenBranch;
  std::shared_ptr<Exp> elseBranch;


  // For VAR_DECLARATION
  std::string varName;
  std::shared_ptr<Exp> varValue;

  // For BLOCK
  std::vector<std::shared_ptr<Exp>> statements;

 // For UNARY_EXP
  std::string unaryOp;
  std::shared_ptr<Exp> operand;


  // Constructors:
  // For NUMBER
  Exp(int number) : type(ExpType::NUMBER), number(number) {}

  // For STRING and SYMBOL
  Exp(const std::string& strVal) {
    if (strVal[0] == '"') {
      type = ExpType::STRING;
      string = strVal.substr(1, strVal.size() - 2);
    } else {
      type = ExpType::SYMBOL;
      string = strVal;
    }
  }


 Exp(const std::string& unaryOp, std::shared_ptr<Exp> operand)
      : type(ExpType::UNARY_EXP), unaryOp(unaryOp), operand(operand) {}


  // For VAR_DECLARATION
  Exp(ExpType expType, const std::string& varName, std::shared_ptr<Exp> varValue)
      : type(expType), varName(varName), varValue(varValue) {}

  // For BINARY_EXP
  Exp(const std::string& op, std::shared_ptr<Exp> left, std::shared_ptr<Exp> right)
      : type(ExpType::BINARY_EXP), op(op), left(left), right(right) {}

  // For IF_EXP
  Exp(ExpType expType, std::shared_ptr<Exp> condition, std::shared_ptr<Exp> thenBranch, std::shared_ptr<Exp> elseBranch)
      : type(expType), condition(condition), thenBranch(thenBranch), elseBranch(elseBranch) {}

  // For BLOCK
  Exp(const std::vector<std::shared_ptr<Exp>>& statements)
      : type(ExpType::BLOCK), statements(statements) {}


};

using Value = std::shared_ptr<Exp>;

%}

%token VAR
%token ASSIGN
%token SEMICOLON
%token IF
%token ELSE


%token L_BRACE
%token R_BRACE
%token L_PAREN
%token R_PAREN

%token NUMBER
%token STRING
%token SYMBOL

%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE

%token EQUALS
%token NOT_EQUALS
%token LESS
%token GREATER
%token LESS_EQUAL
%token GREATER_EQUAL


%token LOGICAL_AND
%token LOGICAL_OR
%token LOGICAL_NOT

%%

Program
  : StatementList { $$ = $1; }
  ;

StatementList
  : Statement
      { $$ = std::make_shared<Exp>(std::vector<std::shared_ptr<Exp>>{ $1 }); }
  | StatementList Statement
      { $1->statements.push_back($2); $$ = $1; }
  ;

Statement
  : MatchedStatement
  | UnmatchedStatement
  ;

MatchedStatement
  : IfStatement
  | OtherStatement
  ;

UnmatchedStatement
  : IfWithoutElse
  ;


IfStatement
  : IF L_PAREN Expression R_PAREN MatchedStatement ELSE MatchedStatement
      { $$ = std::make_shared<Exp>(ExpType::IF_EXP, $3, $5, $7); }
  ;

IfWithoutElse
  : IF L_PAREN Expression R_PAREN Statement
      { $$ = std::make_shared<Exp>(ExpType::IF_EXP, $3, $5, nullptr); }
  ;

OtherStatement
  : VarDeclaration SEMICOLON
      { $$ = $1; }
  | Assignment SEMICOLON
      { $$ = $1; }
  | Expression SEMICOLON
      { $$ = $1; }
  | Block
      { $$ = $1; }
  ;


Block
  : L_BRACE StatementList R_BRACE
      { $$ = std::make_shared<Exp>($2->statements); }
  ;

Assignment
  : SYMBOL ASSIGN Expression
      { $$ = std::make_shared<Exp>(ExpType::ASSIGNMENT, $1, $3); }
  ;

VarDeclaration
  : VAR SYMBOL ASSIGN Expression
      { $$ = std::make_shared<Exp>(ExpType::VAR_DECLARATION, $2, $4); }
  ;


Expression
     : Expression LOGICAL_OR LogicalAndExpression
          { $$ = std::make_shared<Exp>("||", $1, $3); }
      | LogicalAndExpression
          { $$ = $1; }
      ;

LogicalAndExpression
      : LogicalAndExpression LOGICAL_AND EqualityExpression
          { $$ = std::make_shared<Exp>("&&", $1, $3); }
      | EqualityExpression
          { $$ = $1; }
      ;

EqualityExpression
  : EqualityExpression EQUALS RelationalExpression
      { $$ = std::make_shared<Exp>("==", $1, $3); }
  | EqualityExpression NOT_EQUALS RelationalExpression
      { $$ = std::make_shared<Exp>("!=", $1, $3); }
  | RelationalExpression
      { $$ = $1; }
  ;

RelationalExpression
  : RelationalExpression LESS AdditiveExpression
      { $$ = std::make_shared<Exp>("<", $1, $3); }
  | RelationalExpression GREATER AdditiveExpression
      { $$ = std::make_shared<Exp>(">", $1, $3); }
  | RelationalExpression LESS_EQUAL AdditiveExpression
      { $$ = std::make_shared<Exp>("<=", $1, $3); }
  | RelationalExpression GREATER_EQUAL AdditiveExpression
      { $$ = std::make_shared<Exp>(">=", $1, $3); }
  | AdditiveExpression
      { $$ = $1; }
  ;

AdditiveExpression
  : AdditiveExpression PLUS MultiplicativeExpression
      { $$ = std::make_shared<Exp>("+", $1, $3); }
  | AdditiveExpression MINUS MultiplicativeExpression
      { $$ = std::make_shared<Exp>("-", $1, $3); }
  | MultiplicativeExpression
      { $$ = $1; }
  ;

MultiplicativeExpression
  : MultiplicativeExpression MULTIPLY UnaryExpression
      { $$ = std::make_shared<Exp>("*", $1, $3); }
  | MultiplicativeExpression DIVIDE UnaryExpression
      { $$ = std::make_shared<Exp>("/", $1, $3); }
  | UnaryExpression
      { $$ = $1; }
  ;

UnaryExpression
  : LOGICAL_NOT UnaryExpression
      { $$ = std::make_shared<Exp>("!", $2); }
  | PrimaryExpression
      { $$ = $1; }
  ;

PrimaryExpression
  : L_PAREN Expression R_PAREN
      { $$ = $2; }
  | NUMBER
      { $$ = std::make_shared<Exp>(std::stoi($1)); }
  | STRING
      { $$ = std::make_shared<Exp>($1); }
  | SYMBOL
      { $$ = std::make_shared<Exp>($1); }
  ;