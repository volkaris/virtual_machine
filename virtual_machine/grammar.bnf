%lex

%%

\/\/.*             %empty
\/\*[\s\S]*?\*\/   %empty

\s+                %empty

"+"                PLUS
"-"                MINUS
"*"                MULTIPLY
"/"                DIVIDE

"=="               EQUALS
"!="               NOT_EQUALS
"<="               LESS_EQUAL
">="               GREATER_EQUAL
"<"                LESS
">"                GREATER

"if"               IF
"while"            WHILE
"for"              FOR
"var"              VAR

"="                ASSIGN
";"                SEMICOLON

"("                L_PAREN
")"                R_PAREN

"{"                L_BRACE
"}"                R_BRACE

"else"             ELSE

"&&"               LOGICAL_AND
"||"               LOGICAL_OR
"!"                LOGICAL_NOT

\"[^\"]*\"         STRING

\d+                NUMBER

[\w]+              SYMBOL

/lex


%{

#include <string>
#include <vector>
#include <memory>

/**
 * Expression type.
 */
enum class ExpType {
   NUMBER,
    STRING,
    SYMBOL,
    BINARY_EXP,
    UNARY_EXP,
    IF_EXP,
    WHILE_EXP,
    FOR_EXP,
    VAR_DECLARATION,
    BLOCK,
    ASSIGNMENT
};

/**
 * Expression.
 */
struct Exp {
  ExpType type;

  // For NUMBER
  int number;

  // For STRING and SYMBOL
  std::string string;

  // For BINARY_EXP
  std::string op;
  std::shared_ptr<Exp> left;
  std::shared_ptr<Exp> right;

  // For IF_EXP
  std::shared_ptr<Exp> condition;
  std::shared_ptr<Exp> thenBranch;
  std::shared_ptr<Exp> elseBranch;


  // For VAR_DECLARATION
  std::string varName;
  std::shared_ptr<Exp> varValue;

  // For BLOCK
  std::vector<std::shared_ptr<Exp>> statements;

 // For UNARY_EXP
  std::string unaryOp;
  std::shared_ptr<Exp> operand;

 // For WHILE_EXP
  std::shared_ptr<Exp> whileBody;

    // For FOR_EXP
    std::shared_ptr<Exp> forInit;
    std::shared_ptr<Exp> forCondition;
    std::shared_ptr<Exp> forUpdate;
    std::shared_ptr<Exp> forBody;


  // Constructors:
  // For NUMBER
  Exp(int number) : type(ExpType::NUMBER), number(number) {}

  // For STRING and SYMBOL
  Exp(const std::string& strVal) {
    if (strVal[0] == '"') {
      type = ExpType::STRING;
      string = strVal.substr(1, strVal.size() - 2);
    } else {
      type = ExpType::SYMBOL;
      string = strVal;
    }
  }


 Exp(const std::string& unaryOp, std::shared_ptr<Exp> operand)
      : type(ExpType::UNARY_EXP), unaryOp(unaryOp), operand(operand) {}


  // For VAR_DECLARATION
  Exp(ExpType expType, const std::string& varName, std::shared_ptr<Exp> varValue)
      : type(expType), varName(varName), varValue(varValue) {}

  // For BINARY_EXP
  Exp(const std::string& op, std::shared_ptr<Exp> left, std::shared_ptr<Exp> right)
      : type(ExpType::BINARY_EXP), op(op), left(left), right(right) {}

  // For IF_EXP
  Exp(ExpType expType, std::shared_ptr<Exp> condition, std::shared_ptr<Exp> thenBranch, std::shared_ptr<Exp> elseBranch)
      : type(expType), condition(condition), thenBranch(thenBranch), elseBranch(elseBranch) {}

  // For BLOCK
  Exp(const std::vector<std::shared_ptr<Exp>>& statements)
      : type(ExpType::BLOCK), statements(statements) {}

  // For WHILE_EXP
  Exp(ExpType expType, std::shared_ptr<Exp> condition, std::shared_ptr<Exp> whileBody)
      : type(expType), condition(condition), whileBody(whileBody) {}

   Exp(ExpType expType,
        std::shared_ptr<Exp> forInit,
        std::shared_ptr<Exp> forCondition,
        std::shared_ptr<Exp> forUpdate,
        std::shared_ptr<Exp> forBody)
        : type(expType),
          forInit(forInit),
          forCondition(forCondition),
          forUpdate(forUpdate),
          forBody(forBody) {}
};

using Value = std::shared_ptr<Exp>;

%}

%token IF
%token ELSE
%token WHILE
%token FOR
%token VAR
%token ASSIGN
%token SEMICOLON

%token L_BRACE
%token R_BRACE
%token L_PAREN
%token R_PAREN

%token NUMBER
%token STRING
%token SYMBOL

%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE

%token EQUALS
%token NOT_EQUALS
%token LESS
%token GREATER
%token LESS_EQUAL
%token GREATER_EQUAL

%token LOGICAL_AND
%token LOGICAL_OR
%token LOGICAL_NOT

%%

Program
    : StatementList { $$ = $1; }
    ;

StatementList
    : Statement
        { $$ = std::make_shared<Exp>(std::vector<std::shared_ptr<Exp>>{ $1 }); }
    | StatementList Statement
        { $1->statements.push_back($2); $$ = $1; }
    ;

Statement
    : MatchedStatement
    | UnmatchedStatement
    ;

MatchedStatement
    : IfStatement
    | WhileStatement
    | ForStatement
    | OtherStatement
    ;

UnmatchedStatement
    : IfWithoutElse
    ;

IfStatement
    : IF L_PAREN Expression R_PAREN MatchedStatement ELSE MatchedStatement
        { $$ = std::make_shared<Exp>(ExpType::IF_EXP, $3, $5, $7); }
    ;

IfWithoutElse
    : IF L_PAREN Expression R_PAREN Statement
        { $$ = std::make_shared<Exp>(ExpType::IF_EXP, $3, $5, nullptr); }
    ;

WhileStatement
    : WHILE L_PAREN Expression R_PAREN MatchedStatement
        { $$ = std::make_shared<Exp>(ExpType::WHILE_EXP, $3, $5); }
    ;

ForStatement
    : FOR L_PAREN ForInit SEMICOLON ForCondition SEMICOLON ForUpdate R_PAREN MatchedStatement
        { $$ = std::make_shared<Exp>(ExpType::FOR_EXP, $3, $5, $7, $9); }
    ;

ForInit
    : VarDeclaration
        { $$ = $1; }
    | Expression
        { $$ = $1; }
    | %empty
        { $$ = nullptr; }
    ;

ForCondition
    : Expression
        { $$ = $1; }
    | %empty
        { $$ = nullptr; }
    ;

ForUpdate
    : Expression
        { $$ = $1; }
    | %empty
        { $$ = nullptr; }
    ;

OtherStatement
    : VarDeclaration SEMICOLON
        { $$ = $1; }
    | Expression SEMICOLON
        { $$ = $1; }
    | Block
        { $$ = $1; }
    ;

Block
    : L_BRACE StatementList R_BRACE
        { $$ = std::make_shared<Exp>($2->statements); }
    ;

VarDeclaration
    : VAR SYMBOL ASSIGN Expression
        { $$ = std::make_shared<Exp>(ExpType::VAR_DECLARATION, $2, $4); }
    ;

Expression
    : Assignment
    | LogicalOrExpression
    ;

Assignment
    : SYMBOL ASSIGN Expression
        { $$ = std::make_shared<Exp>(ExpType::ASSIGNMENT, $1, $3); }
    ;

LogicalOrExpression
    : LogicalOrExpression LOGICAL_OR LogicalAndExpression
        { $$ = std::make_shared<Exp>("||", $1, $3); }
    | LogicalAndExpression
        { $$ = $1; }
    ;

LogicalAndExpression
    : LogicalAndExpression LOGICAL_AND EqualityExpression
        { $$ = std::make_shared<Exp>("&&", $1, $3); }
    | EqualityExpression
        { $$ = $1; }
    ;

EqualityExpression
    : EqualityExpression EQUALS RelationalExpression
        { $$ = std::make_shared<Exp>("==", $1, $3); }
    | EqualityExpression NOT_EQUALS RelationalExpression
        { $$ = std::make_shared<Exp>("!=", $1, $3); }
    | RelationalExpression
        { $$ = $1; }
    ;

RelationalExpression
    : RelationalExpression LESS AdditiveExpression
        { $$ = std::make_shared<Exp>("<", $1, $3); }
    | RelationalExpression GREATER AdditiveExpression
        { $$ = std::make_shared<Exp>(">", $1, $3); }
    | RelationalExpression LESS_EQUAL AdditiveExpression
        { $$ = std::make_shared<Exp>("<=", $1, $3); }
    | RelationalExpression GREATER_EQUAL AdditiveExpression
        { $$ = std::make_shared<Exp>(">=", $1, $3); }
    | AdditiveExpression
        { $$ = $1; }
    ;

AdditiveExpression
    : AdditiveExpression PLUS MultiplicativeExpression
        { $$ = std::make_shared<Exp>("+", $1, $3); }
    | AdditiveExpression MINUS MultiplicativeExpression
        { $$ = std::make_shared<Exp>("-", $1, $3); }
    | MultiplicativeExpression
        { $$ = $1; }
    ;

MultiplicativeExpression
    : MultiplicativeExpression MULTIPLY UnaryExpression
        { $$ = std::make_shared<Exp>("*", $1, $3); }
    | MultiplicativeExpression DIVIDE UnaryExpression
        { $$ = std::make_shared<Exp>("/", $1, $3); }
    | UnaryExpression
        { $$ = $1; }
    ;

UnaryExpression
    : LOGICAL_NOT UnaryExpression
        { $$ = std::make_shared<Exp>("!", $2); }
    | PrimaryExpression
        { $$ = $1; }
    ;

PrimaryExpression
    : L_PAREN Expression R_PAREN
        { $$ = $2; }
    | NUMBER
        { $$ = std::make_shared<Exp>(std::stoi($1)); }
    | STRING
        { $$ = std::make_shared<Exp>($1); }
    | SYMBOL
        { $$ = std::make_shared<Exp>($1); }
    ;