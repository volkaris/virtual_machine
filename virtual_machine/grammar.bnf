%lex

%%

\/\/.*             %empty
\/\*[\s\S]*?\*\/   %empty

\s+                %empty

"+"                PLUS
"-"                MINUS
"*"                MULTIPLY
"/"                DIVIDE

"=="               EQUALS
"!="               NOT_EQUALS
"<="               LESS_EQUAL
">="               GREATER_EQUAL
"<"                LESS
">"                GREATER

"if"               IF
"while"            WHILE
"for"              FOR
"var"              VAR

"func"             FUNC

"="                ASSIGN
";"                SEMICOLON

"("                L_PAREN
")"                R_PAREN

"{"                L_BRACE
"}"                R_BRACE

"else"             ELSE

"&&"               LOGICAL_AND
"||"               LOGICAL_OR
"!"                LOGICAL_NOT

\"[^\"]*\"         STRING

\d+                NUMBER

[\w]+              SYMBOL

/lex


%{

#include <string>
#include <vector>
#include <memory>

enum class ExpType {
    NUMBER,
    STRING,
    SYMBOL,
    BINARY_EXP,
    UNARY_EXP,
    IF_EXP,
    WHILE_EXP,
    FOR_EXP,
    VAR_DECLARATION,
    BLOCK,
    ASSIGNMENT,
    FUNCTION_DECLARATION,
    FUNCTION_CALL,
    PARAM_LIST,    // NEW: to hold function parameter lists
    ARG_LIST       // NEW: to hold function argument lists
};

struct Exp {
    ExpType type;

    int number;
    std::string string;

    std::string op;
    std::shared_ptr<Exp> left;
    std::shared_ptr<Exp> right;

    std::shared_ptr<Exp> condition;
    std::shared_ptr<Exp> thenBranch;
    std::shared_ptr<Exp> elseBranch;

    std::string varName;
    std::shared_ptr<Exp> varValue;

    std::vector<std::shared_ptr<Exp>> statements;

    std::string unaryOp;
    std::shared_ptr<Exp> operand;

    std::shared_ptr<Exp> whileBody;

    std::shared_ptr<Exp> forInit;
    std::shared_ptr<Exp> forCondition;
    std::shared_ptr<Exp> forUpdate;
    std::shared_ptr<Exp> forBody;

    std::string funcName;
    std::vector<std::string> funcParams; // For PARAM_LIST or FUNCTION_DECLARATION
    std::shared_ptr<Exp> funcBody;

    std::vector<std::shared_ptr<Exp>> callArguments; // For ARG_LIST or FUNCTION_CALL

    // Constructors

    // For PARAM_LIST
    Exp(ExpType type, const std::vector<std::string> &params)
        : type(type), funcParams(params) {}

    // For ARG_LIST
    Exp(ExpType type, const std::vector<std::shared_ptr<Exp>> &args)
        : type(type), callArguments(args) {}

    // FUNCTION_DECLARATION constructor
    Exp(ExpType type, const std::string &name, const std::vector<std::string> &params, std::shared_ptr<Exp> body)
        : type(type), funcName(name), funcParams(params), funcBody(body) {}

    // FUNCTION_CALL constructor
    Exp(ExpType type, const std::string &name, const std::vector<std::shared_ptr<Exp>> &args)
        : type(type), funcName(name), callArguments(args) {}

    // For NUMBER
    Exp(int number) : type(ExpType::NUMBER), number(number) {}

    // For STRING and SYMBOL
    Exp(const std::string& strVal) {
        if (strVal[0] == '"') {
            type = ExpType::STRING;
            string = strVal.substr(1, strVal.size() - 2);
        } else {
            type = ExpType::SYMBOL;
            string = strVal;
        }
    }

    // For UNARY_EXP
    Exp(const std::string& unaryOp, std::shared_ptr<Exp> operand)
        : type(ExpType::UNARY_EXP), unaryOp(unaryOp), operand(operand) {}

    // For VAR_DECLARATION
    Exp(ExpType expType, const std::string& varName, std::shared_ptr<Exp> varValue)
        : type(expType), varName(varName), varValue(varValue) {}

    // For BINARY_EXP
    Exp(const std::string& op, std::shared_ptr<Exp> left, std::shared_ptr<Exp> right)
        : type(ExpType::BINARY_EXP), op(op), left(left), right(right) {}

    // For IF_EXP
    Exp(ExpType expType, std::shared_ptr<Exp> condition, std::shared_ptr<Exp> thenBranch, std::shared_ptr<Exp> elseBranch)
        : type(expType), condition(condition), thenBranch(thenBranch), elseBranch(elseBranch) {}

    // For BLOCK
    Exp(const std::vector<std::shared_ptr<Exp>>& statements)
        : type(ExpType::BLOCK), statements(statements) {}

    // For WHILE_EXP
    Exp(ExpType expType, std::shared_ptr<Exp> condition, std::shared_ptr<Exp> whileBody)
        : type(expType), condition(condition), whileBody(whileBody) {}

    // For FOR_EXP
    Exp(ExpType expType,
        std::shared_ptr<Exp> forInit,
        std::shared_ptr<Exp> forCondition,
        std::shared_ptr<Exp> forUpdate,
        std::shared_ptr<Exp> forBody)
        : type(expType),
          forInit(forInit),
          forCondition(forCondition),
          forUpdate(forUpdate),
          forBody(forBody) {}
};

using Value = std::shared_ptr<Exp>;

%}

%token IF
%token ELSE
%token WHILE
%token FOR
%token VAR
%token FUNC

%token ASSIGN
%token SEMICOLON

%token L_BRACE
%token R_BRACE
%token L_PAREN
%token R_PAREN

%token NUMBER
%token STRING
%token SYMBOL

%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE

%token EQUALS
%token NOT_EQUALS
%token LESS
%token GREATER
%token LESS_EQUAL
%token GREATER_EQUAL

%token LOGICAL_AND
%token LOGICAL_OR
%token LOGICAL_NOT

%%

Program
    : StatementList { $$ = $1; }
    ;

StatementList
    : Statement
        { $$ = std::make_shared<Exp>(std::vector<std::shared_ptr<Exp>>{ $1 }); }
    | StatementList Statement
        { $1->statements.push_back($2); $$ = $1; }
    ;

Statement
    : MatchedStatement
    | UnmatchedStatement
    ;

MatchedStatement
    : IfStatement
    | WhileStatement
    | ForStatement
    | FunctionDeclaration
    | OtherStatement
    ;

UnmatchedStatement
    : IfWithoutElse
    ;

IfStatement
    : IF L_PAREN Expression R_PAREN MatchedStatement ELSE MatchedStatement
        { $$ = std::make_shared<Exp>(ExpType::IF_EXP, $3, $5, $7); }
    ;

IfWithoutElse
    : IF L_PAREN Expression R_PAREN Statement
        { $$ = std::make_shared<Exp>(ExpType::IF_EXP, $3, $5, nullptr); }
    ;

WhileStatement
    : WHILE L_PAREN Expression R_PAREN MatchedStatement
        { $$ = std::make_shared<Exp>(ExpType::WHILE_EXP, $3, $5); }
    ;

ForStatement
    : FOR L_PAREN ForInit SEMICOLON ForCondition SEMICOLON ForUpdate R_PAREN MatchedStatement
        { $$ = std::make_shared<Exp>(ExpType::FOR_EXP, $3, $5, $7, $9); }
    ;

ForInit
    : VarDeclaration
        { $$ = $1; }
    | Expression
        { $$ = $1; }
    | %empty
        { $$ = nullptr; }
    ;

ForCondition
    : Expression
        { $$ = $1; }
    | %empty
        { $$ = nullptr; }
    ;

ForUpdate
    : Expression
        { $$ = $1; }
    | %empty
        { $$ = nullptr; }
    ;

OtherStatement
    : VarDeclaration SEMICOLON
        { $$ = $1; }
    | Expression SEMICOLON
        { $$ = $1; }
    | Block
        { $$ = $1; }
    ;

FunctionDeclaration
    : FUNC SYMBOL L_PAREN ParameterList R_PAREN Block
        {
            // $4 is a PARAM_LIST Exp containing funcParams
            $$ = std::make_shared<Exp>(
                 ExpType::FUNCTION_DECLARATION,
                 $2,
                 $4->funcParams,
                 $6
            );
        }
    ;

Block
    : L_BRACE StatementList R_BRACE
        { $$ = std::make_shared<Exp>($2->statements); }
    ;

VarDeclaration
    : VAR SYMBOL ASSIGN Expression
        { $$ = std::make_shared<Exp>(ExpType::VAR_DECLARATION, $2, $4); }
    ;

Expression
    : Assignment
    | LogicalOrExpression
    ;

Assignment
    : SYMBOL ASSIGN Expression
        { $$ = std::make_shared<Exp>(ExpType::ASSIGNMENT, $1, $3); }
    ;

LogicalOrExpression
    : LogicalOrExpression LOGICAL_OR LogicalAndExpression
        { $$ = std::make_shared<Exp>("||", $1, $3); }
    | LogicalAndExpression
        { $$ = $1; }
    ;

LogicalAndExpression
    : LogicalAndExpression LOGICAL_AND EqualityExpression
        { $$ = std::make_shared<Exp>("&&", $1, $3); }
    | EqualityExpression
        { $$ = $1; }
    ;

EqualityExpression
    : EqualityExpression EQUALS RelationalExpression
        { $$ = std::make_shared<Exp>("==", $1, $3); }
    | EqualityExpression NOT_EQUALS RelationalExpression
        { $$ = std::make_shared<Exp>("!=", $1, $3); }
    | RelationalExpression
        { $$ = $1; }
    ;

RelationalExpression
    : RelationalExpression LESS AdditiveExpression
        { $$ = std::make_shared<Exp>("<", $1, $3); }
    | RelationalExpression GREATER AdditiveExpression
        { $$ = std::make_shared<Exp>(">", $1, $3); }
    | RelationalExpression LESS_EQUAL AdditiveExpression
        { $$ = std::make_shared<Exp>("<=", $1, $3); }
    | RelationalExpression GREATER_EQUAL AdditiveExpression
        { $$ = std::make_shared<Exp>(">=", $1, $3); }
    | AdditiveExpression
        { $$ = $1; }
    ;

AdditiveExpression
    : AdditiveExpression PLUS MultiplicativeExpression
        { $$ = std::make_shared<Exp>("+", $1, $3); }
    | AdditiveExpression MINUS MultiplicativeExpression
        { $$ = std::make_shared<Exp>("-", $1, $3); }
    | MultiplicativeExpression
        { $$ = $1; }
    ;

MultiplicativeExpression
    : MultiplicativeExpression MULTIPLY UnaryExpression
        { $$ = std::make_shared<Exp>("*", $1, $3); }
    | MultiplicativeExpression DIVIDE UnaryExpression
        { $$ = std::make_shared<Exp>("/", $1, $3); }
    | UnaryExpression
        { $$ = $1; }
    ;

UnaryExpression
    : LOGICAL_NOT UnaryExpression
        { $$ = std::make_shared<Exp>("!", $2); }
    | PrimaryExpression
        { $$ = $1; }
    ;

PrimaryExpression
    : L_PAREN Expression R_PAREN
        { $$ = $2; }
    | NUMBER
        { $$ = std::make_shared<Exp>(std::stoi($1)); }
    | STRING
        { $$ = std::make_shared<Exp>($1); }
    | SYMBOL L_PAREN ArgumentList R_PAREN
        {
           // $3 is ARG_LIST Exp
           $$ = std::make_shared<Exp>(
                 ExpType::FUNCTION_CALL,
                 $1,
                 $3->callArguments
               );
        }
    | SYMBOL
        { $$ = std::make_shared<Exp>($1); }
    ;

ParameterList
    : /* empty */
        {
          $$ = std::make_shared<Exp>(ExpType::PARAM_LIST, std::vector<std::string>());
        }
    | SymbolList
        { $$ = $1; }
    ;

SymbolList
    : SYMBOL
        {
          std::vector<std::string> params = {$1};
          $$ = std::make_shared<Exp>(ExpType::PARAM_LIST, params);
        }
    | SymbolList "," SYMBOL
        {
          // $1 is PARAM_LIST Exp
          $1->funcParams.push_back($3);
          $$ = $1;
        }
    ;

ArgumentList
    : /* empty */
        {
          $$ = std::make_shared<Exp>(ExpType::ARG_LIST, std::vector<std::shared_ptr<Exp>>());
        }
    | ExpressionList
        { $$ = $1; }
    ;

ExpressionList
    : Expression
        {
          std::vector<std::shared_ptr<Exp>> args = {$1};
          $$ = std::make_shared<Exp>(ExpType::ARG_LIST, args);
        }
    | ExpressionList "," Expression
        {
          // $1 is ARG_LIST Exp
          $1->callArguments.push_back($3);
          $$ = $1;
        }
    ;
