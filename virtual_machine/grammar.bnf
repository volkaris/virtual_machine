/**
 *
 * syntax-cli -g src/parser/grammar.bnf -m LALR1 -o parser.h
 *
 */

// -----------------------------------------------
// Lexical grammar (tokens):

%lex

%%

\/\/.*             %empty
\/\*[\s\S]*?\*\/   %empty

\s+                %empty

"("                L_PAREN
")"                R_PAREN

"+"                PLUS
"-"                MINUS
"*"                MULTIPLY
"/"                DIVIDE


"=="               EQUALS
"!="               NOT_EQUALS
"<="               LESS_EQUAL
">="               GREATER_EQUAL
"<"                LESS
">"                GREATER


"if"               IF


\"[^\"]*\"         STRING

\d+                NUMBER

[\w]+              SYMBOL


/lex

// -----------------------------------------------
// Syntactic grammar (BNF):

%{

#include <string>
#include <vector>
#include <memory>

/**
 * Expression type.
 */
enum class ExpType {
  NUMBER,
  STRING,
  SYMBOL,
  BINARY_EXP,  // For binary expressions like 5+10
    IF_EXP,
};

/**
 * Expression.
 */
struct Exp {
  ExpType type;

  int number;
  std::string string;
  std::string symbol;

  std::string op;
  std::shared_ptr<Exp> left;
  std::shared_ptr<Exp> right;

        std::shared_ptr<Exp> condition;
        std::shared_ptr<Exp> thenBranch;
        std::shared_ptr<Exp> elseBranch;

  // Constructors:
  Exp(int number) : type(ExpType::NUMBER), number(number) {}

  Exp(const std::string& strVal) {
    if (strVal[0] == '"') {
      type = ExpType::STRING;
      string = strVal.substr(1, strVal.size() - 2);
    } else {
      type = ExpType::SYMBOL;
      symbol = strVal;
    }
  }

 Exp(ExpType expType, std::shared_ptr<Exp> condition, std::shared_ptr<Exp> thenBranch, std::shared_ptr<Exp> elseBranch)
            : type(expType), condition(condition), thenBranch(thenBranch), elseBranch(elseBranch) {}


  Exp(const std::string& op, std::shared_ptr<Exp> left, std::shared_ptr<Exp> right)
      : type(ExpType::BINARY_EXP), op(op), left(left), right(right) {}
};

using Value = std::shared_ptr<Exp>;

%}


%token IF

%%

Exp
  : Expression { $$ = $1; }
  ;

Expression
  : Expression PLUS Term       { $$ = std::make_shared<Exp>("+", $1, $3); }
  | Expression MINUS Term      { $$ = std::make_shared<Exp>("-", $1, $3); }
  | Expression EQUALS Term     { $$ = std::make_shared<Exp>("==", $1, $3); }
  | Expression NOT_EQUALS Term { $$ = std::make_shared<Exp>("!=", $1, $3); }
  | Expression LESS Term       { $$ = std::make_shared<Exp>("<", $1, $3); }
  | Expression GREATER Term    { $$ = std::make_shared<Exp>(">", $1, $3); }
  | Expression LESS_EQUAL Term { $$ = std::make_shared<Exp>("<=", $1, $3); }
  | Expression GREATER_EQUAL Term { $$ = std::make_shared<Exp>(">=", $1, $3); }
  | Term                       { $$ = $1; }
  ;

Term
  : Term MULTIPLY Factor       { $$ = std::make_shared<Exp>("*", $1, $3); }
  | Term DIVIDE Factor         { $$ = std::make_shared<Exp>("/", $1, $3); }
  | Factor                     { $$ = $1; }
  ;

Factor
  : IfExpression               { $$ = $1; }
  | L_PAREN Expression R_PAREN { $$ = $2; }
  | NUMBER                     { $$ = std::make_shared<Exp>(std::stoi($1)); }
  | STRING                     { $$ = std::make_shared<Exp>($1); }
  | SYMBOL                     { $$ = std::make_shared<Exp>($1); }
  ;

IfExpression
  : L_PAREN IF Expression Expression R_PAREN
      { $$ = std::make_shared<Exp>(ExpType::IF_EXP, $3, $4, nullptr); }
  | L_PAREN IF Expression Expression Expression R_PAREN
    { $$ = std::make_shared<Exp>(ExpType::IF_EXP, $3, $4, $5); }
  ;